# 为什么NIO回导致CPU 100%

## Java有3种IO类型

### BIO

这个IO工作方式也是非常的简单，就是来一个连接我就创建一个线程进行处理，

### NIO

NIO就是利用了操作系统的多路复用实现了一个线程可以处理多个任务，

epoll为例，当来任务了我们线程会接受任务去异步执行， 当执行好了会通知我们线程，我们处理好了，然后线程就告诉给线程任务的连接告诉他我处理好了。

### AIO

这个和BIO的区别一个是堵塞io一个非堵塞。无需等待IO成功。立刻返回。当io执行完了，会调用函数通知程序。

## NIO出现的占用问题

如果我们多路复用器轮询的结果为null，也没有wakeup和新消息要处理，他会一直空轮训，导致cpu100%。

### 如何造成的空轮询

也就是说出现了RST（强制连接关闭），因为poll和epoll对中断的连接会返回eventSet事件集合为pollhup或者pollerr，eventSet事件集合发生了变化，就会导致selector会被唤醒这就是导致CPu100%。准确来说是JDK没有处理好这个事情。比如SelectionKey种没有定义有异常事件的类型

## 解决方案

## 升级JDK

jdk升级到1.8版本，jdk解决了这个问题，但是还是可能出现这个问题，只是几率变低了。

## 使用第三方库

使用Netty，如果检测到可能空轮询，他可能会临时增加selector的等待时间，或者重建selector，避免CPU的资源浪费