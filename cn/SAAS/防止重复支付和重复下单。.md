# 防止重复支付和重复下单。

## 1,分布式锁的保护

~~~java
// 用户级分布式锁
String lockKey = SubscriptionConstant.SUB_OPER_KEY_PREFIX + userId;
RLock lock = redissonClient.getLock(lockKey);
boolean lockFlag = lock.tryLock(0, 30, TimeUnit.SECONDS);
Assert.isTrue(lockFlag, ResponseCode.REQUEST_FREQUENCY_TOO_FAST);
~~~

## 2,重复订单检测

~~~java
public void boolvideoDuplicateCreateSubscriptionBeforeCheckByOrder(Integer userId, SubOrigin subOrigin) {
    // 1. 检查待支付订单
    List<OrdersEntity> list = ordersService.lambdaQuery()
        .eq(OrdersEntity::getCustomerId, userIdStr)
        .eq(OrdersEntity::getState, OrderState.WAIT_PAYMENT.getName())
        .in(OrdersEntity::getOrderType, OrderType.FIRST_SUBSCRIPTION_COMMON_ORDER, OrderType.FIRST_SUBSCRIPTION_FREE_TRIAL_ORDER)
        .list();
    Assert.isTrue(list.isEmpty(), OrderResponseCode.CURRENT_SUBSCRIPTION_EXIST);

    // 2. 检查当前有效订阅
    UserSub currentPeriodSub = userResourceV3Biz.getUserCurrentPeriodSub(userId, subOrigin);
    Assert.isNull(currentPeriodSub, OrderResponseCode.CURRENT_SUBSCRIPTION_EXIST);
}
~~~

检查用户是否有待支付订单，有则阻止。

检查用户是否有有效订单，有则阻止。

## 3,创建订单

~~~java
// 创建待支付订单
OrdersEntity ordersEntity = boolvideoOrderOperService.genWaitPaymentOrder(genStripeWaitPaymentOrderParams);
~~~

在数据库中创建订单，订单状态标记为待支付

## 4,调用Stripe API

~~~java
// 构造幂等键
String idempotencyKey = UUID.fastUUID().toString();
RequestOptions requestOptions = RequestOptions.builder().setIdempotencyKey(idempotencyKey).build();

// 创建Stripe订阅
Subscription subscription = Subscription.create(subscriptionCreateParams, requestOptions);
~~~

使用幂等key防止Stripe端重复创建

创建Stripe订阅获取支付Link

## 5.绑定订单与Stripe订单

~~~json
// 绑定Stripe数据到订单
ordersEntity = boolvideoOrderOperService.bindStripeDataToNewSubOrder(
    BoolvideoBindStripeDataToOrderParams.builder()
        .ordersEntity(ordersEntity)
        .subscriptionId(subscription.getId())
        .invoiceId(invoice.getId())
        .build()
);
~~~

将Stripe订阅的ID、发票ID等绑定到本地。

## 6. Webhook回调处理

验证WebHook签名，防止伪造。根据事件类型更新本地订单状态。 也要记得做一些幂等性处理。

~~~java
// Stripe支付成功回调
@PostMapping("/stripe/webhooks")
public String handleStripeWebhook(@RequestBody String payload, @RequestHeader("Stripe-Signature") String sigHeader) {
    // 验证签名
    Event event = Webhook.constructEvent(payload, sigHeader, endpointSecret);
    
    // 根据事件类型处理
    switch (event.getType()) {
        case "invoice.paid":
            handleInvoicePaid(event);
            break;
        case "charge.refunded":
            handleChargeRefunded(event);
            break;
    }
}
~~~

## 7.防重复表机制

~~~java
CommonUniqueTaskEntity commonUniqueTaskEntity = new CommonUniqueTaskEntity();
commonUniqueTaskEntity.setUserId(userId);
commonUniqueTaskEntity.setSource(source);
commonUniqueTaskEntity.setEventType(eventType);
commonUniqueTaskEntity.setEventId(eventId);
commonUniqueTaskService.insert(commonUniqueTaskEntity);
~~~

每个事件都有唯一ID，防止重复处理。

数据库唯一约束确保同一事件只处理一次。

