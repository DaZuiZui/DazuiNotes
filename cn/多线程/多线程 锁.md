# 多线程 锁

## 悲观锁

​	被关锁总是假设最坏的情况， 认为共享数据每次访问都有可能出现问题，所以每次在获取资源操作的时候会上锁，也就是说这个共享资源同一时间只能有一个线程在操作，比如synchronized和ReentranLock就是被关锁的思想。

适合写比较多的情况，因为他的开销是固定的。

## 乐观锁

乐观锁总是假设最好的情况，认为访问资源的时候不会出现问题，只是在修改数据的时候去验证对应的资源是否被其他线程修改了，严重的方法使用版本号机制和CAS实现。

在java的atomic下的原子变量类都是使用了CAS实现的。

CAS的缺点是如果我们发生冲突，会频繁的失败和重试，这样会非常的影响性能。

乐观锁适合写少多读的场景。

## 版本号机制

一般在数据表中加上一个数据版本号version字段， 表示被修改的次数，如果我们的数据被修改了version就会+1，当线程要更新数据的时候，首先会读取version值，然后在提交更新的时候判断这个version值和我刚才读取的是否一样，如果一样就提交更新然后更新version值。

## CAS算法

CAS就是Compare And Swap（比较与交换）他的工作原理就是用一个预期值和一个要更新的变量进行比较，两者相等才会进行更新。

CAS是一个原子操作，底层一来一条CPU的原子指令。

CAS主要设计到3个操作数

**V：**变量的原值		**E：**预期值		**N：**要写入的值

当且仅当V的值等于E时，CAS通过原子方式用新值N来更新V的值。

假如线程A要修改变了i的值为12， i的原值为1（V=1,E=12,N=12）如果e==n那么就可以修改证明其他线程没有进行操作，否则就不修改。

## CAS算法会触发的ABA问题

当一个变量初次读取是12，然后准备赋值的时候检测的时候依然是12，这时候不能排除没有被其他线程修改，很可能已经被其他线程修改为3，然后在修改为12，这个就是ABA问题。解决ABA的方法就是在变量前面增加时间戳或者版本号

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功会有很大的开销。

## synchronized

在Java16版本之前synchronized是重量级锁，重量锁就是当线程无法获取锁的时候，它会被堵塞，等待锁的释放，内核态切换：因为涉及到操作系统层面的献策很难过调度，因此会导致我们用户态切换到内核态，带来性能开开销。

### 在jdk1.6及之后的表现

引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁（JDK18中取消），轻量级锁来优化。

**锁消除**：就是对一些不必要的锁进行消除。

**锁粗化：**是针对段时间内频繁枷锁解锁的代码进行优化技术。他就是把多个连续加锁解锁操作合并为一个更大范围的锁操作，比如说一个循环内，一个方法内出现多次的，他们都是用的一个锁对象。那么JIT编译器可能会将这些连续的加锁解锁操作合并为一个更大的范围的锁操作。这么做就是为了减少加锁解锁的次数。

**偏向锁**：它持有锁的时候其他线程无法竞争，如果发生其他线程竞争了，那么就会撤销锁，然后考虑升级为适合多线程竞争的锁。

**轻量级锁**： 首先会使用CAS尝试原子性的标志位设置为锁定状态。如果成功就获取锁成功，否则就失败转换为重量级，减少了锁竞争带来的性能损失。 重量级就是同时只有一个线程持有锁。



```java
synchronized void method() {
    //锁的对象实列
}
```



```java
synchronized static void method() {
    //锁的类
}
```



```java
synchronized(this) {
  //synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。
  //synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁
}
```