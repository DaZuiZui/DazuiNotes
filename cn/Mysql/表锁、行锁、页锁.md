# 表锁、行锁、页锁

## 表锁

**表的锁定：**使用lock table的时候会锁表

**DDl操作：** 对表使用Alter table、create table这种变更结构的操作会触发表锁。

## 行锁

**隔离级别：**read committed隔离下，innodb会使用行锁。在使用Repreatable read隔离下也会使用行锁，但是事物开启会读取数据快照。

**锁的操作：**使用FOR UPDATE 或者 FOR SHARE也会触发行锁

**事物的操作：**事物执行update和delete的时候会行锁

## 页锁

使用页锁的目标就是减少竞争，提高并发量，当一个事物获取事物的页锁，其他事物想执行，需要等待页锁匙放，这是控制并发机制的一部分需要保证事物的隔离性。

**大范围扫描：**当使用大范围查询会页锁。

**事物的隔离级别：**当使用read committed、read uncommitted的隔离级别或者select for update 数据库可能倾向使用页锁保证隔离性。

**索引冲突：**如果多个事物同时尝试修改同一索引的不同部分，可能会使用页锁。



**行锁更合适：**如果我们数据库检测当前页只有少数几行被修改，其他事物需要等待就会转换为行锁，

**减少冲突：**如果我们的页锁导致了较大的锁冲突会考虑降为行锁，减少事物之间的竞争和冲突。

**提升并发性：**为了提高整体的并发量，系统可能会根据实际的情况灵活调整锁的级别。

## 间隙锁

间隙锁用于范围条件的检索操作，比如我们用到betten就会在这个范围之间上间隙锁，防止这个范围内插入新的数据导致幻读。保证范围查询的一致性，让其他事物不能在这个范围插入数据防止了幻读。

## 意向锁

​	多个事物可能都想在想通的资源（表、页、行）上设置不同类型的锁（共享锁、排它锁）。意向锁协调这些锁的请求，减少锁冲突，让数据库更好的控制并发。

​	**意向共享锁：**表示某个事物打算在资源上设置共享锁，如果事物想要在资源上设置共享锁首先要获取意向共享锁。

​	**意向排它锁：**	表示某个事物打算在资源上设置排它锁，如果事物想要在资源上设置共享锁首先要获取意向排它锁。

## 排他锁

在INNODB引擎当我们的隔离级别为Serializable的时候在更新的时候就会使用排他锁，这个锁可以让其他事物进行读，但是同一时刻只能一个事物进行上排他锁，不可以排它锁和共享锁同时出现，因为锁是互斥的，但是我看资料有一些数据库两个锁可以同时存在，但是mysql不可以。



扩展知识，如果是Read Uncommitted隔离级别下，使用for update 和for share指定返回的数据行,如果是read commited获取的是行锁。

## 共享锁

共享锁就是多个事物用来读取同一个资源，如果其他事物想进行写，需要等共享锁完全释放。然后拿到排它锁。
