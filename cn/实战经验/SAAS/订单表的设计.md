# 订单表设计核心

## 实现

### 从业务角度

这个纬度主要是确定订单的完成生命周期，从创建、支付、发货到完成都要考虑到。

### 数据维度方面

订单会拆分为几张表。

主表主要存放核心信息，订单商品表存商品明细

还有就是订单状态变更表记录每次状态流转。

### 性能方面

必须订单号为会用雪花算法生成
又保证唯一性又有排序性，索引设计上会重点考虑用户Id，订单状态和创建时间这些常用的查询字段

## 为什么不用自增ID

自增ID确实比较简单暴力，但是分布式系统下会有一些问题。
首先唯一性难保证，多个数据库实例会容易冲突。

其次就是安全性不会，懂点技术的用户可以推算出订单量

我一般用雪花算法，41位时间戳+10位机器id+12位序列号，这样能保证全剧唯一，又能大致按照时间排序。

## 状态方面怎么设计

一般这种有标识性的状态我都会设计为枚举值。

比如待支付，完成支付，取消等

每个状态之间流转都必须有严格的业务规则，不可以随意跳动，比如从待支付直接跳到发货了。

状态变更为会单独建立一张表记录。
包括订单id，原状态，新的状态，变更时间，操作人等。

不管怎么设计都要遵守方便做数据分析和异常排查

代码层面为会用状态机方式来控制状态流转，确保每次变更都符合业务规则避免出现脏数据

## 百万订单怎么优化

也是常见的优化方案吧，我会分库分表，我会按照用户id做hash分批，

这样用户相关的订单都在一个分片里了。查询效率比较高，避免了跨库关联。

然后就是读写分析，写走主库，查走从库。
如果查询频繁的还可以加redis缓存。设置合理的过期时间减轻数据库的压力。
订单方面还可以做热冷分离，比如3个月以前的扔历史表。

## 订单和商品的关联关系怎么处理？商品变更会影响到历史订单的影响吗

会影响到，所以我一般都是特殊处理下，在订单商品明细表里记录iAd安时的商品名称、加个、规格等，这样即使后续商品信息变更，历史订单显示也不会收到影响。
当然这样也会有数据永余，但是对于订单这种核心的业务准确性的优先级会更高，而且这么设计也方便分析。

## 超卖问题

最开始是先查后减的方法，

高并发会出现竞争条件，后面改为redis原子操作进行扣减。

扣减成功才可以创建订单，然后通过MQ异步更新数据库库存。

这样有保障了数据库的准确性又保证了速度

## 幂等

我会生成一个唯一的请求token，前端第一次请求的时候获取这个token，提交订单的时候携带这个token，然后服务器对这个token进行校验这样保证的
