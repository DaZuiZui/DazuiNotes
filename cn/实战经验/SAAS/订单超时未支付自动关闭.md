# 订单超时未支付自动关闭

##  定时任务

通过固定时间扫描数据库

## 通过消息队列的延迟消息

通过消息队列的延迟消息，但是要考虑消息堆积和消费者重试机制。

注意的事情就是单个任务要放在同一个事物里面，避免丢失消息。

消费端一定要做幂等性处理，防止网络重试导致重复关单。

**像rocketMQ只能支持固定延迟级别，**不能精确到秒。如果遇见大批流量可能需要动态扩容消费者。

~~~java
例如 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h

~~~

还有一个细节就是要二次校验订单状态，

比如消费者处理消息的时候，先查询数据库确定订单的确没有支付，否则可能出现订单支付成功然后关闭订单的消息也进行处理了。 所以这时候可以使用redis分布式锁来锁定。

这个业务最核心的设计原则是 最终一致性优先，不强求定时关闭，但是要保证不漏单，第二个就是防御性设计，任何环节都可能失败，要有补偿机制。第三个就是监控闭环，要实时统计关单延迟指标，失败重试次数指标（失败多少次）。

**关单延迟指标 是  订单“理论应该被关闭的时间” 到 “实际被系统关闭的时间”之间的时间差**

## REdis Key

设置订单ID的TTL来触发回调，但是这个方法有点坑在集群模式下，比如主从切换可能导致事件丢失，

TTL是过期时间，这个方法需要Redis开通过期事件通知。

踩过的坑：如果redis内存不够了， 触发了主动淘汰策略，那么key就会被提前删除。

还有集群环境下，如果主节点挂了， 从节点不会触发过期事件通知，而且redis过期事件通知还有延迟，极端情况都会有1-2分钟延迟。

所以我一般不会用redis去做这个事情。

如果一定要用必须要做双重保障，比如在数据库记录实际关闭时间，每天凌晨定时任务扫一次异常数据防止漏掉没有关闭的。

然后redis的key，TTL要比实际超时多出5分钟留一下缓冲时间

## Mysql

Mysql事件调度器定期执行存储过程。
